این گزارش‌ها، مربوط به جلسات تیم اسمبلی هاردوار ۲۰۲۰ در اردیبهشت ۱۳۹۸ است.

## جلسه اول

سلام
همون طور که توی اسکایپ گفتم، قراره که اول با شبیه‌ساز کار کنیم و اگر رسیدیم، دستگاه اسمبلی رو هم بسازیم.
فعلا برای قسمت شبیه‌ساز(سیمولاتور یا امولاتور) این کارا هست که باید انجام بدیم:
۱) یک یا چند تا شبیه‌ساز باید پیدا کنیم که امکان استفاده ازش توی مسابقه باشه و ترجیحا روی همه سیستم های مک، ویندوز و اوبونتو کار کنه.
۲) مسلط شدن کار با سیمولاتور(های) انتخاب شده.
۲) طرح مساله و سوال برای مسابقه و درست کردن کلید.


## جلسه دوم

جمع بندی جلسه امشب(قسمت امولاتور مسابقه):

- درمورد امولاتور ها صحبت کردیم (قرار شد که همه سوالات بر اساس یک ISA طراحی بشن که بهتره با مشورت یک یا چند استاد ببینیم کدوم ISA باید انتخاب بشه).

- اینکه سوالا توی چند سطح باشه که سه سطح شد (دست گرمی، سخت و نهایی) که بخش آخرش (نهایی) یه حالت رقابتی طور داره.

- روی روش طرح سوال هم صحبت شد:
  - میتونیم توی سوالات دست‌گرمی، کدها رو از لحاظ زمان یا استفاده مموری یا تعداد خط کد ارزیابی کنیم.
  - یه ایده این بود که برای بخش آخر که رقابتی هست یه معماری طراحی کنیم که توش دو تا کد (از دو تا تیم متفاوت) باهم روی یک معماری اجرا بشن ولی مموری هاشون مشترکه (یه معماری با دو تا CPU ولی یک مموری مشترک) و باید یک محاسبه‌ای رو انجام بده (مثلا جمع ۱۰ تا عدد از پیش تعریف شده). تیم‌ها توانایی این رو دارند که مموری طرف مقابل رو بازنویسی کنن و توی کارش مزاحمت ایجاد کنن. در آخر تیمی که زودتر به جواب درست برسه برنده هست...
  - میشه مثل AIC هم مرحله آخر رو برگزار کرد تنها فرقش با AIC اینه که کد به زبان اسمبلی هست (بازی‌ای که توش رقابت میکنن هم باید خیلی ساده تر باشه...)

- تا اونجایی که میشه بهتره با روش‌ها و تکنیک‌های مختلف کد زدن اسمبلی، شرکت کننده ها رو آشنا کرد: مثلا یه سوال این باشه که فرض کنیم Data Memory و Instruction Memory یکی هست(اینطوری وسط اجرا کد، خوده کد میاد دستورها رو تغییر می‌ده) . 
یا اینکه می‌تونه اینطوری باشه که این دو تا مموری از هم جدا باشن.
میتونیم بگیم توی بعضی سوال‌ها باید از یک دستور خاصی استفاده بشه (مثلا IBM صد تا دستور داره که ممکنه کلا با ۱۰تاش کار کرده باشیم و بد نباشه بگیم از اون ۹۰ تای دیگه هم استفاده کنین...)

- بحث دیگه این بود که داکیومنت آموزشی بدیم که شرکت کننده‌ها قبل از مسابقه اونو بخونن و آماده بشن.

## جلسه سوم

سلام،
همون طور که توی جلسه آخرمون گفتم قرار شد که یه امولاتور خودمون بسازیم به کمک فریمورکِ Unicorn و از ISA MIPS استفاده می‌کنیم.

برای همین بر مبنای همین MIPS باید سوال اسمبلی طرح کنیم. سوال هامون باید با مساله‌های رایجی که توی تمرین و پروژه‌های واحد ساختار زبان تدریس می‌شه فرق کنه. توی جلسه دوممون راجع به تیپ مساله‌هایی که باید طرح کنیم صحبت کردیم. نکته هایی که باید توی طرح سوال و نحوه امتیاز دادن بهشون توجه کنیم اینا بود:

- میزان زمان اجرا، تعداد خط کد و میزان استفاده از حافظه توی میزان امتیاز هر تیم میتونه تاثیر بذاره.

- میتونه در سبک AIC تیم ها دو به دو باهم رقابت کنند.

- یه جوری باشه که نیاز به مطالعه زیاد یا استفاده از دستورهای عجیب غریب نشه، باید سعی کرد که شرکت کننده با کمترین میزان مطالعه بتونه با دستورهای ساده (مثل branch ,add یا ...) کارش رو راه بندازه. 

- دستمون بازه که اگر خواستیم، دستور دلبخواه یا ترکیبی از چند دستور به ISA اضافه کنیم.


پس کلا دو جور کار(مسولیت) داریم؛ طراحی سوال و طراحی امولاتور. 

طراحی سوال رو که باید هممون توش درگیر بشیم و هر کدوممون هر ایده ای به ذهنمون میرسه برای طرح مساله ویا بالا بردن جذابیت سوالا مطرح کنیم.

برای امولاتور باید چندنفر بشینیم و حداقل کاری که کنیم اینه که یه امولاتور ساده برای MIPS با python بسازیم بعد باید با توجه به نوع سوالا ظاهر گرافیکی هم به سوال اضافه کنیم(pyQT). این کار رو اگر خوب انجام بدین برای رزومه و جلب نظر استادا می‌تونه خیلی تاثیر بذاره...

## جلسه چهارم

سلام،
برای امولاتورسازها:
  همونطور که میدونین قرار شده که از فریمورک unicron استفاده کنیم برای ساخت امولاتورمون. این فریمورک یه سری امکانات داره که میشه باهاش یه CPU رو شبیه سازی کرد و به کمک تابع هاش دید که مموری یا رجیسترهاش در چه حالتی هستند یا چه مقداری دارند. 
- قراره که از معماری MIPS استفاده کنیم که این فریمورک ازش support میکنه.
- زبون برناممون python3 هستش.
- قراره ورودی امولاتورمون یه فایل باشه که دستور ها رو خط به خط اجرا میکنه. توی این فایل قراره که دستورها بصورت کلمه و عددهای انگلیسی باشه (قرار نیست باینری بهش داده بشه)؛ مثلا اینجوری توی فایل ورودی نوشته می‌شه:
✅add r1,r2,r3
نه اینجوری:
❌0000000000001000100001100000100000
پس برای همین یه بخش اصلی که امولاتور ما انجام میده اینه که هر خط از فایل رو به کد باینری(کد ماشین) تبدیل کنه و در شبیه ساز اجرا کنه.

اگر میتونین این لینکه رو ببینین:
http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf


کارهایی که داریم:
۱)فریمورک unicorn رو نصب کنین:
pip install unicorn

۲) مثال MIPS رو اجرا کنین و ببینین تابع هاش چیکار میکنن (چجوری رجیستر یا مموری خونده میشه و ...):
https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_mips.py

۳) (یه نفر این رو انجام بده) یه برنامه بنویسیم که از یه فایل text که توش دستورهای اسمبلی MIPS نوشته شده خونده بشه و به کد باینری تبدیل بشه. دستورها و opcode های مربوطه رو میتونین از این فایله دریافت کنین (یا میتونین توی گوگل پیدا کنین):
https://uweb.engr.arizona.edu/~ece369/Resources/spim/MIPSReference.pdf

۴) کد نوشته شده توی قسمت ۳ رو کامل کنیم و یه امولاتور کامل پیاده کنیم که صرفا یه فایل با دستورات اسمبلی رو دریافت کنه و اون ها رو اجرا کنه.

۵) کد نوشته شده توی بخش ۴ رو کامل تر کنیم و با توجه به نوع سوالهایی که میخوایم طرح کنیم، GUI اضافه کنیم(مثلا میشه صرفا مقدار های رجیسترها و PC رو نشون بده یا صفحه نمایش بازی Minesweeper باشه که نشون میده کد برنامه داره چجوری عمل میکنه) . توی این بخش نیازه که از pyQT استفاده کنیم.
